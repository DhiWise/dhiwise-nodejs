
<%_
let isCombinedOutputDefined = false;
function getRandomInt(max) {
    return Math.floor(Math.random() * max);
  }
_%>
<%_if(FILE_UPLOAD){_%>
<%_if(S3_UPLOAD){_%>
const fs = require('fs');
const path = require('path');
const formidable = require('formidable');
const AWS = require('aws-sdk');
<%_if(S3_UPLOAD_PRIVATE){_%>
const AmazonS3URI = require('amazon-s3-uri');
<%_}_%> 
<%_} else {_%>
const fs = require('fs');
const path = require('path');
const formidable = require('formidable');
const validUrl = require('valid-url');
<%_}_%>
<%_}_%>
const {Op} = require("sequelize");
const deleteDependentService = require("../../../utils/deleteDependent")
const message = require("../../../utils/messages");
const models = require("../../../model");
<%_var customRouteServices=[]
if(SERVICES_TO_IMPORT && SERVICES_TO_IMPORT.length){
    for(let i=0;i < SERVICES_TO_IMPORT.length;i++){ 
        if(SERVICES_TO_IMPORT[i] != DB_MODEL){ 
            customRouteServices.push(`${SERVICES_TO_IMPORT[i]}Service`)
        }else{
            customRouteServices.push(`${SERVICES_TO_IMPORT[i]}Service1`)
        }
    }
}
_%>
<%_ var methods = [] _%>
<%_ if((UNIQ_TASK_MODELS && UNIQ_TASK_MODELS.length)){ %>
function make<%-DB_MODEL_FC%>Controller({
    <%-DB_MODEL%>Service,make<%-DB_MODEL_FC%><%if(IS_AUTH){%>,authService<%_}_%> 
    <%_
        let entities=UNIQ_TASK_MODELS
        if(entities){
        let entityFC=""
        for(const entity of entities){ 
            entityFC=entity.charAt(0).toUpperCase() + entity.slice(1); 
            if(DB_MODEL !== entity){_%>
    ,make<%-entityFC%>, <%-entity%>CqService, <%-entity%>Service
    <%_} } } _%>
    <%_if(customRouteServices.length){_%>,<%-customRouteServices.join()%><%_}_%>
})
<%_ }else{_%>
function make<%-DB_MODEL_FC%>Controller({<%-DB_MODEL%>Service,make<%-DB_MODEL_FC%><%if(IS_AUTH){%>,authService<%_}_%><%_if(customRouteServices.length){_%>,<%-customRouteServices.join()%><%_}_%>})
<%_}_%>
{
<%_for(let i=0;i< SUPPORT_API.length;i++){ _%>
<%_ if(SUPPORT_API[i].method=="create") {_%>
    <%_methods.push('add'+DB_MODEL_FC) _%> 
    const add<%-DB_MODEL_FC%> = async ({ data <%_ if(SUPPORT_API[i].isLogin){ _%> ,loggedInUser <%_}_%>}) => {
        try {
            const originalData = data;
            delete originalData.addedBy
            delete originalData.updatedBy
            <%_ if(SUPPORT_API[i].isLogin){ _%>
              originalData.addedBy=loggedInUser.id
            <%_ } _%>
            const <%-DB_MODEL%> = make<%-DB_MODEL_FC%>(originalData, 'insert<%-DB_MODEL_FC%>Validator');
            let created<%-DB_MODEL_FC%> = await <%-DB_MODEL%>Service.createOne(<%-DB_MODEL%>)
              <%_if(SUPPORT_API[i].fieldSelection){_%>
            created<%-DB_MODEL_FC%> = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(created<%-DB_MODEL_FC%>);
            <%_}_%>
            return message.successResponse({data:created<%-DB_MODEL_FC%>});
          } catch (error) {
            if (error.name === 'ValidationError') {
              return message.inValidParam({message : error.message});
            }
            return message.failureResponse();
          }
        };
<%_}_%>
<%_ if(SUPPORT_API[i].method=="createBulk") {_%>
  <%_methods.push('bulkInsert'+DB_MODEL_FC) _%>
  const bulkInsert<%-DB_MODEL_FC%> = async({body<%_ if(SUPPORT_API[i].isLogin){ _%> ,loggedInUser <%_}_%>})=>{
    try{
      let data = body.data;
      const <%-DB_MODEL%>Entities=data.map((item)=>{
        delete item.addedBy
        delete item.updatedBy
        <%_ if(SUPPORT_API[i].isLogin){ _%>
        item.addedBy=loggedInUser.id
        <%_ } _%>
        return make<%-DB_MODEL_FC%>(item,"insert<%-DB_MODEL_FC%>Validator")
      })
      const results = await <%-DB_MODEL%>Service.createMany(<%-DB_MODEL%>Entities)
      return message.successResponse({data:results});
    }catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
  }
<%_}_%>
<%_ if(SUPPORT_API[i].method=="partialUpdate") {_%>
  <%_methods.push('partialUpdate'+DB_MODEL_FC) _%>
  const partialUpdate<%-DB_MODEL_FC%> = async (id,data<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) =>{
      try {
        if (data && id){          
          const <%-DB_MODEL %> = make<%-DB_MODEL_FC%>(data,'update<%-DB_MODEL_FC%>Validator');
          const filterData = removeEmpty(<%-DB_MODEL %>);
          <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
          let query = {}
          if (loggedInUser){
              query = {
                  "id": {
                      [Op.eq]: id,
                      [Op.ne]: loggedInUser.id
                  }
              }
          } else{
            return message.badRequest();
          }
          <%_}else{_%>
          let query = {id:id}
          <%_}_%>
          let updated<%-DB_MODEL_FC%> = await <%-DB_MODEL %>Service.updateMany(query,filterData);
          <%_if(SUPPORT_API[i].fieldSelection){_%>
          updated<%-DB_MODEL_FC%> = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(updated<%-DB_MODEL_FC%>);
          <%_}_%>
          return message.successResponse({data:updated<%-DB_MODEL_FC%>});
        }
        return message.badRequest();
      }
      catch (error){
        if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
        }
        return message.failureResponse();
      }
    }
<%_}_%>
<%_ if(SUPPORT_API[i].method=="update") {_%>
  <%_methods.push('update'+DB_MODEL_FC) _%>
  const update<%-DB_MODEL_FC%> = async (pk, data<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) =>{
      try {
        if (pk){          
          delete data.addedBy
          delete data.updatedBy
          <%_ if(SUPPORT_API[i].isLogin){ _%>
              data.updatedBy=loggedInUser.id
          <%_ } _%>
          const <%-DB_MODEL %> = make<%-DB_MODEL_FC%>(data,'update<%-DB_MODEL_FC%>Validator');
          const filterData = removeEmpty(<%-DB_MODEL %>);
          <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
          let query = {}
          if (loggedInUser){
              query = {
                  "id": {
                      [Op.eq]: pk,
                      [Op.ne]: loggedInUser.id
                  }
              }
          } else{
            return message.badRequest();
          }
          <%_}else{_%>
          let query = {id:pk}
          <%_}_%>
          <%_         
          let nestedCalls={}
          if(SUPPORT_API[i].IS_NESTED_CALL){
              nestedCalls = SUPPORT_API[i].NESTED_CALLS
              if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                  for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                      <%-element.existingVariable%> = <%=JSON.parse(element.filter)%>
                  <%_}}
              }                
          }
          _%>
          let updated<%-DB_MODEL_FC%> = await <%-DB_MODEL %>Service.updateMany(query,filterData);
          <%_if(SUPPORT_API[i].fieldSelection){_%>
          updated<%-DB_MODEL_FC%> = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(updated<%-DB_MODEL_FC%>);
          <%_}_%>
          return message.successResponse({data:updated<%-DB_MODEL_FC%>});
        }
        return message.badRequest();
      }
      catch (error){
        if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
        }
        return message.failureResponse();
      }
    }
<%_}_%>
<%_ if(SUPPORT_API[i].method=="bulkUpdate") {_%>
  <%_methods.push('bulkUpdate'+DB_MODEL_FC) _%>
  const bulkUpdate<%-DB_MODEL_FC%> = async(data<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) =>{
    try{
      if(data.filter && data.data){
        delete data.data.addedBy
        delete data.data.updatedBy
        <%_ if(SUPPORT_API[i].isLogin){ _%>
            data.data.updatedBy=loggedInUser.id
        <%_ } _%>
        const <%-DB_MODEL%> = make<%-DB_MODEL_FC%>(data.data,"update<%-DB_MODEL_FC%>Validator")
        const filterData=removeEmpty(<%-DB_MODEL%>);
        <%_         
        nestedCalls={}
        if(SUPPORT_API[i].IS_NESTED_CALL){
            nestedCalls = SUPPORT_API[i].NESTED_CALLS
            if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                data.filter = <%=JSON.parse(element.filter)%>                                            
                <%_}}
            }                
        }
        _%>
        const updated<%-DB_MODEL_FC%>s = await <%-DB_MODEL%>Service.updateMany(data.filter,filterData);
        return message.successResponse({data:updated<%-DB_MODEL_FC%>s});
      }
      return message.badRequest();
    }catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
  }
<%_}_%>
<%_ if(SUPPORT_API[i].method=="delete") {_%>
  <%_methods.push('delete'+DB_MODEL_FC) _%>
    const delete<%-DB_MODEL_FC%> = async (pk, body<%_if(SUPPORT_API[i].isLogin){_%>,loggedInUser,<%_}_%>options={})=>{
      try {
        if(!pk){
          return message.badRequest();
        }
        <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
        let query = {}
        if (loggedInUser){
            query = {
                "id": {
                    [Op.eq]: pk,
                    [Op.ne]: loggedInUser.id
                }
            }
        } else{
            return message.badRequest();
        }
        <%_}else{_%>
        let query = {id:pk}
        <%_}_%>
        <%_         
        nestedCalls={}
        if(SUPPORT_API[i].IS_NESTED_CALL){
            nestedCalls = SUPPORT_API[i].NESTED_CALLS
            if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                    <%-element.existingVariable%> = <%=JSON.parse(element.filter)%>    
                <%_}}
            }                
        }
        _%>
        <%_ if(DELETE_DEPENDENT_MODEL){ _%>
          let deleted<%-DB_MODEL_FC%>=""
          if(isWarning){
            deleted<%-DB_MODEL_FC%> = await deleteDependentService.count<%-DB_MODEL_FC%>(query);
          }else{
            deleted<%-DB_MODEL_FC%> = await deleteDependentService.delete<%-DB_MODEL_FC%>(query);
          }
        <%_}else{ _%>
          deleted<%-DB_MODEL_FC%> = await <%-DB_MODEL%>Service.deleteByPk(pk,options);  
      <%_ }_%>
        return message.successResponse({data:deleted<%-DB_MODEL_FC%>});
      } catch (error) {
        if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
        }
        return message.failureResponse();
      }
    }
<%_}_%>
<%_ if(SUPPORT_API[i].method=="deleteMany") {_%>
    <%_methods.push('deleteMany'+DB_MODEL_FC) _%>
    <%_ if(DELETE_DEPENDENT_MODEL){ _%>
const deleteMany<%-DB_MODEL_FC%> =async(data<%_if(SUPPORT_API[i].isLogin){_%>, loggedInUser<%_}_%>) => {
    try{
        if(data && data.ids){
          let ids = data.ids
          <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
          let query = {}
          if (loggedInUser){
              query = {
                  id: {
                      [Op.in]: ids,
                      [Op.ne]: loggedInUser.id
                  }
              }
          } else{
            return message.badRequest();
          }
          <%_}else{_%>
          let query = {id:{[Op.in]: ids}}
          <%_}_%>
            let result;
            if(data.isWarning){
               result = await deleteDependentService.count<%-DB_MODEL_FC%>(query);
            }
            else{
              result = await deleteDependentService.delete<%-DB_MODEL_FC%>(query);
            }
            return message.successResponse({data:result});
        }
        return message.badRequest();
    }
    catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
  }
<%_ } else { _%>
const deleteMany<%-DB_MODEL_FC%> =async(ids<%_if(typeof USER_MODEL !== 'undefined' && USER_MODEL){_%>, loggedInUser<%_}_%>) => {
    try{
        if(!ids || !Array.isArray(ids) || ids.length < 1){
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
            let query = {}
            if (loggedInUser){
                query = {
                    id: {
                        [Op.in]: ids,
                        [Op.ne]: loggedInUser.id
                    }
                }
            } else{
              return message.badRequest();
            }
            <%_}else{_%>
            let query = {id:{[Op.in]: ids}}
            <%_}_%>
            let result = await <%-DB_MODEL%>Service.deleteMany(query);
            return message.successResponse({data:result});
        }
        return message.badRequest();
    }
    catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
}
<%_ } _%>
<%_ } _%>

<%_ if(SUPPORT_API[i].method=="softDelete") {_%>
  <%_methods.push('softDelete'+DB_MODEL_FC) _%>
  const softDelete<%-DB_MODEL_FC%> = async({pk<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>},options={})=>{
    try{
        if(pk){
          let updated<%-DB_MODEL_FC%>
          <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
          let query = {}
          if (loggedInUser){
              query = {
                  id: {
                      [Op.eq]: pk,
                      [Op.ne]: loggedInUser.id
                  }
              }
          }else{
            return message.badRequest();
          }
          <%_}else{_%>
          let query={id:pk}
          <%_}_%>
          <%_         
          nestedCalls={}          
          if(SUPPORT_API[i].IS_NESTED_CALL){
              nestedCalls = SUPPORT_API[i].NESTED_CALLS
              if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                  for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                      <%-element.existingVariable%> = <%=JSON.parse(element.filter)%> 
                  <%_}}
              }                
          }
          _%>
          <%_ if(DELETE_DEPENDENT_MODEL){ _%>      
            updated<%-DB_MODEL_FC%> = await deleteDependentService.softDelete<%-DB_MODEL_FC%>(query<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser.id<%_}_%>);            
          <%_}else{_%>
            updated<%-DB_MODEL_FC%> = await <%-DB_MODEL%>Service.softDeleteMany(query, options<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser.id<%_}_%>);
          <%_}_%>
          return message.successResponse({data:updated<%-DB_MODEL_FC%>});
        }
        return message.badRequest();
    }catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
  }
<%_}_%>
<%_ if(SUPPORT_API[i].method=="softDeleteMany") {_%>
    <%_methods.push('softDeleteMany'+DB_MODEL_FC) _%>
    <%_ if(DELETE_DEPENDENT_MODEL){ _%>
const softDeleteMany<%-DB_MODEL_FC%> = async (ids<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) => {
    try{
        if(!ids || !Array.isArray(ids) || ids.length < 1){
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
            let query = {}
            if (loggedInUser){
                query = {
                    id: {
                        [Op.in]: ids,
                        [Op.ne]: loggedInUser.id
                    }
                }
            } else{
              return message.badRequest();
            }
            <%_}else{_%>
            let query = {id:{[Op.in]: ids,}}
            <%_}_%>
            let data = await deleteDependentService.softDelete<%-DB_MODEL_FC%>(query<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser.id<%_}_%>);
            return message.successResponse({data});
        }
        return message.badRequest();
    }catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
}
<%_ } else { _%>
const softDeleteMany<%-DB_MODEL_FC%> = async (ids<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) => {
    try{
        if(!ids || !Array.isArray(ids) || ids.length < 1){
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
            let query = {}
            if (loggedInUser){
                query = {
                    id: {
                        [Op.in]: ids,
                        [Op.ne]: loggedInUser.id
                    }
                }
            } else{
              return message.badRequest();
            }
            <%_}else{_%>
            let query = {id:{[Op.in]: ids,}}
            <%_}_%>
            const options={}
            let data = await <%-DB_MODEL%>Service.softDeleteMany(query,options<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser.id<%_}_%>);
            return message.successResponse({data});
        }
        return message.badRequest();
    }catch(error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
}
<%_ } _%>
<%_ } _%>

<%_ if(SUPPORT_API[i].method=="findAll") {_%>
  <%_methods.push('findAll'+DB_MODEL_FC) _%>
    const findAll<%-DB_MODEL_FC%> = async ({ data<%_ if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>}) => {
      try {
        let query = {};
        let options = {};
        if (data.query !== undefined){
          query = { ...data.query };
        }
        if(data.options !== undefined){
          options = { ...data.options };
        }
        query = <%-DB_MODEL%>Service.queryBuilderParser(query);
        <%_ if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
        if (loggedInUser){
            query = {
              ...query,
             id: { [Op.ne]: loggedInUser.id }
            }
            if (data.query && data.query.id) {
                Object.assign(query.id, { [Op.in]: [data.query.id] })
            }
        } else{
            return message.badRequest();
        }
        <%_}_%>
        <%_if(SUPPORT_API[i].fieldSelection){_%>
          if(options && options.select && options.select.length){
              options.attributes = <%=SUPPORT_API[i].fields%>.filter(Set.prototype.has, new Set(options.select));
          }else{
              options.attributes=<%=SUPPORT_API[i].fields%>
          }
        <%_} else {_%>
        if(options && options.select && options.select.length){
          options.attributes = options.select;
        }
        <%_}_%>
        if (options && options.sort){
          options.order = <%-DB_MODEL%>Service.sortParser(options.sort);
          delete options.sort;
        }
        let result;  
        if (options && options.include && options.include.length){
            let include = [];
            options.include.forEach(i => {
            i.model = models[i.model];
            if (i.query) {
                i.where = <%-DB_MODEL%>Service.queryBuilderParser(i.query);
            }
            include.push(i);
            });
            options.include = include;
        }  
        <%_         
        nestedCalls={}
        if(SUPPORT_API[i].IS_NESTED_CALL){
            nestedCalls = SUPPORT_API[i].NESTED_CALLS
            if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                    <%-element.existingVariable%> = <%=JSON.parse(element.filter)%> 
                <%_}}
            }                
        }
        _%> 
        if (data.isCountOnly){
          result = await <%-DB_MODEL%>Service.count(query, options);
          return message.successResponse({data:result});
        } else {
          result = await <%-DB_MODEL%>Service.findMany(query, options);
        } 
        if (result){
         return message.successResponse({data:result});
        } else {
          return message.badRequest();
        }
      }
      catch (error){
        if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
        }
        return message.failureResponse();
      }
    };
<%_}_%>
<%_ if(SUPPORT_API[i].method=="findById") {_%>
  <%_methods.push('find'+DB_MODEL_FC+'ByPk') _%>
  const find<%-DB_MODEL_FC%>ByPk = async (pk,options={}) => {
    try {
      <%_if(SUPPORT_API[i].fieldSelection){_%>
      options.attributes = <%=SUPPORT_API[i].fields%>
      <%_}_%>
      let result = await <%-DB_MODEL%>Service.findByPk(pk, options);   
      if (result){
        return message.successResponse({data:result});
      } else {
        return message.recordNotFound();
      }    
    }
    catch (error){
      if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
      }
      return message.failureResponse();
    }
  };
<%_}_%>
<%_}_%>
<%_if(typeof USER_MODEL !== "undefined" && USER_MODEL){_%>
  <%_methods.push('changePassword'); methods.push('updateProfile');  _%>
  const changePassword = async (params) => {
      try {
          if (!params.newPassword || !params.userId || !params.oldPassword) { 
              return message.inValidParam({message:'Please Provide userId and Password'});
          }
          let result = await authService.changePassword(params);
          if (result.flag) {
                return message.invalidRequest({message:result.data});
            }
            return message.requestValidated({message:result.data});
      } catch (error) {
        if (error.name === 'ValidationError') {
          return message.inValidParam({message : error.message});
        }
        return message.failureResponse();
      }
  }     
  const updateProfile = async(data,id) =>{
        try{
          if(id && data){
            if(data.password) delete data.password;
            if(data.createdAt) delete data.createdAt;
            if(data.updatedAt) delete data.updatedAt;
            if(data.id) delete data.id;
            const user = make<%-DB_MODEL_FC%>(data,"update<%-DB_MODEL_FC%>Validator");
            const filterData = removeEmpty(user);
            let updated<%-DB_MODEL_FC%> = await <%-DB_MODEL%>Service.updateByPk(id,filterData);
            return message.successResponse({data:updated<%-DB_MODEL_FC%>});
          }
          return message.badRequest();
        }
        catch(error){
          if (error.name === 'ValidationError') {
            return message.inValidParam({message : error.message});
          }
          return message.failureResponse();
        }
    };   
<%_}_%>
<%_if(CUSTOM_ROUTES){_%>
  <%_CUSTOM_ROUTES.forEach((v,i)=>{ 
      methods.push(v.functionName)
      _%>
      <%_if(typeof(v.descriptions)!=='undefined'){_%>
      /* 
      * <%-v.descriptions%>
      */
      <%_}_%>
      const <%-v.functionName%> =async(data) =>{
          try{
              const <%-v.service%> = data
              
          <%_if(typeof(v.queryBuilder) !== "undefined" && v.queryBuilder.length > 0){_%>
              const combinedOutput = {}
              let result = <%_if(v.service==DB_MODEL){_%><%-v.service%>Service1<%_}else{_%><%-v.service%>Service<%_}_%>.<%-v.functionName%>();
              <%_ 
              const elements = v.queryBuilder
              for(let element of elements){ 
                  let elementModel_FC=""
                  if(element.queryMode !== 'codeBlock' && element.model){ 
                      elementModel_FC=element.model.charAt(0).toUpperCase() + element.model.slice(1);
                  }
              if(["findOneAndDelete","deleteMany"].includes(element.queryMode)){ _%>
              let <%-element.outputVariable%>=await <%-element.model%>CqService.<%-element.queryMode%>(<%-JSON.stringify(JSON.parse(element.filter))%>,<%-JSON.stringify(element.option)%>);
              <%_if(typeof element.outputSelect !== "undefined" && element.outputSelect.length){ element.outputSelect.push("id") _%>
              <%-element.outputVariable%> = (({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}))(<%-element.outputVariable%>);
              <%_}_%>
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_ } else if(["findOneAndUpdate","updateMany"].includes(element.queryMode)){ _%> 
              let <%-element.outputVariable%>=await <%-element.model%>CqService.<%-element.queryMode%>(<%-JSON.stringify(JSON.parse(element.filter))%>,
                  make<%-elementModel_FC%>(<%-JSON.stringify(element.data)%>,"update<%-elementModel_FC%>Validator"),
                  <%-JSON.stringify(element.option)%>);
              <%_if(typeof element.outputSelect !== "undefined" && element.outputSelect.length){ element.outputSelect.push("id") _%>
              <%-element.outputVariable%> = (({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}))(<%-element.outputVariable%>);
              <%_}_%>
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_ } else if(element.queryMode=="create"){ _%>                 
              let <%-element.outputVariable%>=await <%-element.model%>CqService.<%-element.queryMode%>(
                  make<%-elementModel_FC%>(<%-JSON.stringify(element.data)%>,"insert<%-elementModel_FC%>Validator"),
                  <%-JSON.stringify(element.option)%>);
              <%_if(typeof element.outputSelect !== "undefined" && element.outputSelect.length){ element.outputSelect.push("id") _%>
              <%-element.outputVariable%> = (({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}))(<%-element.outputVariable%>);
              <%_}_%>
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_ } else if(element.queryMode === "codeBlock"){_%>
                  <%-element.code%>
              <%_} else if(element.queryMode === "find" && element.model){_%>
              const <%-element.queryVarName%> = {}
              <%_if(element.filter){ _%>
              <%-element.queryVarName%>.filter =<%-element.filter%>
              <%_}_%>
              <%_if(element.skip){ _%>
              <%-element.queryVarName%>.skip = <%-JSON.stringify(element.skip)%>
              <%_}_%>
              <%_if(element.limit){ _%>
              <%-element.queryVarName%>.limit = <%-JSON.stringify(element.limit)%>
              <%_}_%>
              <%_if(element.populate && element.populate.length>0){ _%>
              <%-element.queryVarName%>.populate = <%-JSON.stringify(element.populate)%>
              <%_}_%>
              <%_if(element.sort){ _%>
              <%-element.queryVarName%>.order = <%=printSequelizeSort(JSON.parse(element.sort))%>
              <%_}_%>
              <%_if(element.select){ _%>
              <%-element.queryVarName%>.attributes = <%-JSON.stringify(element.select)%>
              <%_}_%>
              
              const <%-element.outputVariable%> = await <%-element.model%>CqService.<%-element.queryMode%>(<%-element.queryVarName%>)
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_}else if(element.queryMode === 'aggregate'){ _%>
              combinedOutput.<%-element.outputVariable%> = await <%-element.model%>CqService.<%-element.queryMode%>(<%-JSON.stringify(element.pipes)%>)
              <%_ } else if(element.queryMode === 'fileUpload'){ _%>
              <%_if(S3_UPLOAD){_%>

              let allowedFileTypes = <%=element.validationType%>;<%_var max_size = element.maxSize ? element.maxSize : 5%>
              let maxFileSize = <%=max_size%>; //In Megabyte

              // Setting up formidable options.
              const form = new formidable.IncomingForm();
              form.multiples = true;
              form.maxFileSize = 300 * 1024 * 1024; //300 MB
              form.maxFieldsSize = 100 * 1024 * 1024; //50 MB

              const uploadFileRes = await new Promise(async (resolve, reject) => {
              form.parse(req, async function (err, fields, files) { 

                let filePaths = [];
                let fileCount = 1;

                let fileArr = [];
                if (!files['file[]'] || files['file[]'].size == 0) {
                resolve({
                    'err': 'Please Select any one File',
                    'status': false
                });
                }
                if (!Array.isArray(files['file[]'])) {
                fileArr.push(files['file[]']);
                files['file[]'] = fileArr;
                }

                for (let file of files['file[]']) {
                let response = await uploadFiles(file,fields,fileCount++,allowedFileTypes, maxFileSize);
                if (response.status == false) {
                    filePaths.push({
                    'name': file.name,
                    'err': response.message,
                    'status': false
                    });
                } else {
                    filePaths.push({
                    'path': response.data,
                    'status': true
                    });
                }
              }
                resolve(filePaths);

            });
            });
            <%_if(S3_UPLOAD_PRIVATE){_%>
            let finalResponse = [];
            if (Array.isArray(uploadFileRes) && uploadFileRes.length){
                uploadFileRes = await new Promise(async (resolve, reject) => {
                    for (let u of uploadFileRes){
                    if (u.status && u.path) {
                        u = await generatePreSignedURL(u.path);
                        finalResponse.push(u);
                    }
                    }
                    resolve(finalResponse);
                });
            }
            <%_}_%>
        <%_} else {_%>

            let defaultDirectory = 'public/assets'
            let allowedFileTypes = <%=element.validationType%>;<%_ var max_size = element.maxSize ? element.maxSize : 5 _%>
            let maxFileSize = <%=max_size%>; //In Megabyte

            // Create Directory if not exist.
            await makeDirectory(defaultDirectory);

            // Setting up formidable options.
            const form = new formidable.IncomingForm();
            form.multiples = true;
            form.maxFileSize = 300 * 1024 * 1024; //300 MB
            form.maxFieldsSize = 100 * 1024 * 1024; //50 MB

            //Upload File one by one
            const uploadFileRes = await new Promise(async (resolve, reject) => {

            form.parse(req, async function (err, fields, files) {

                let filePaths = [];
                let fileCount = 1;

                let fileArr = [];
                if (!files['file[]'] || files['file[]'].size == 0) {
                resolve({
                    'err': 'Please Select any one File',
                    'status': false
                });
                }
                if (!Array.isArray(files['file[]'])) {
                fileArr.push(files['file[]']);
                files['file[]'] = fileArr;
                }

                for (let file of files['file[]']) {

                let response = await uploadFiles(file, fields, fileCount++,allowedFileTypes, maxFileSize, defaultDirectory);

                if (response.status == false) {
                    filePaths.push({
                    'name': file.name,
                    'err': response.message,
                    'status': false
                    });
                } else {
                    let url = response.data;
                    if (!validUrl.isUri(response.data)) {
                    response.data = response.data.replace('/public', '');
                    url = `${response.data}`;
                    }
                    filePaths.push({
                    'path': url,
                    'status': true
                    });
                }
                }
                resolve(filePaths);
            });
        });
        <%_}_%>
              combinedOutput.uploadFileRes = uploadFileRes; 
              <%_}_%>
          <%_ } _%>
          <%_ } _%>
          <%_if(typeof(v.queryBuilder) !== "undefined" && v.queryBuilder.length > 0){_%>
              if(combinedOutput){
                return message.successResponse({data:combinedOutput});
              }
          <%_}else{_%>
              let result = <%_if(v.service==DB_MODEL){_%><%-v.service%>Service1<%_}else{_%><%-v.service%>Service<%_}_%>.<%-v.functionName%>();
              if(result){
                return message.successResponse({data:result});
              }
          <%_}_%>
              
          }catch(error){
            if(error.name==="ValidationError"){
              return message.inValidParam({message:error.message});
            }
            return message.failureResponse();
          }
      }
  <%_})_%>
  <%_}_%>

    const removeEmpty = (obj) => {
        Object.entries(obj).forEach(([key,value])=>{
            if(value === undefined){
                delete obj[key]
            }
        })
        return obj
    };

    return Object.freeze({
        <%-methods.join(',')%>
    })
}

<%_if(FILE_UPLOAD){_%>
<%_if(S3_UPLOAD){_%>
async function uploadFiles (file,fields,fileCount,allowedFileTypes, maxFileSize){

  let extension = path.extname(file.name);
  extension = extension.split('.').pop();

  fileType = file.type;

  if (allowedFileTypes.length) {
    //Check allowed extension;
    if (!allowedFileTypes.includes(extension)) {
      return {
        status: false,
        message: 'Filetype not allowed.'
      };
    }
  }

  // Check File Size
  const fileSize = ((file.size / 1024) / 1024);
  if (maxFileSize < fileSize) {
    return {
      status: false,
      message: `Allow file size upto ${maxFileSize} MB.`
    };
  }

  let fileName = file.name;
  //Create Requested Directory,if given in request parameter.
  if (fields && fields.folderName) {
    fileName = fields.folderName + '/' + fileName;
  }
  else if (fields && fields.fileName) {
    fileName = fields.fileName + '-' + fileCount + path.extname(file.name);
  }

  const response = await new Promise(async (resolve, reject) => {
    resolve(await uploadToS3(file,fileName));
  });

  return response;

}

async function uploadToS3 (file, fileName){
  let S3Config = {
    AWS_S3_ACCESS_KEY_ID: process.env.AWS_S3_ACCESS_KEY_ID,
    AWS_S3_SECRET_ACCESS_KEY: process.env.AWS_S3_SECRET_ACCESS_KEY,
    AWS_S3_REGION: process.env.AWS_S3_REGION,
    AWS_S3_BUCKET_NAME: process.env.AWS_S3_BUCKET_NAME,
  };

  const s3 = new AWS.S3({
    region: S3Config.AWS_S3_REGION,
    accessKeyId: S3Config.AWS_S3_ACCESS_KEY_ID,
    secretAccessKey: S3Config.AWS_S3_SECRET_ACCESS_KEY
  });

  let params = {
    Bucket: S3Config.AWS_S3_BUCKET_NAME,
    Body: fs.createReadStream(file.path),
    Key: fileName,
  };

  const response = await new Promise(async (resolve, reject) => {
    s3.putObject(params, function (err, data) {
      if (err) {
        resolve({
          status: false,
          message: err.message
        });
      } else {
        resolve({
          status: true,
          data: 'https://' + process.env.AWS_S3_BUCKET_NAME + '.s3.' + S3Config.AWS_S3_REGION + '.amazonaws.com/' + fileName
        });
      }
    });
  });

  return response;
}
<%_if(S3_UPLOAD_PRIVATE){_%>
async function generatePreSignedURL (uri){
  if (uri){
    let S3Config = {
      AWS_S3_ACCESS_KEY_ID: process.env.AWS_S3_ACCESS_KEY_ID,
      AWS_S3_SECRET_ACCESS_KEY: process.env.AWS_S3_SECRET_ACCESS_KEY,
      AWS_S3_REGION: process.env.AWS_S3_REGION,
      AWS_S3_BUCKET_NAME: process.env.AWS_S3_BUCKET_NAME,
    };

    const s3 = new AWS.S3({
      region: S3Config.AWS_S3_REGION,
      accessKeyId: S3Config.AWS_S3_ACCESS_KEY_ID,
      secretAccessKey: S3Config.AWS_S3_SECRET_ACCESS_KEY
    });

    const {
      region, bucket, key 
    } = AmazonS3URI(uri);

    let options = {
      Bucket: bucket,
      Key: key,
      Expires: 1 * 60 * 60, // 1 hour
    };

    let response = await new Promise(async (resolve,reject)=>{
      await s3.getSignedUrl('getObject', options, (err, url) => {
        if (err) {
          resolve({
            status: false,
            err: err,
          });
        } else {
          resolve({
            status: true,
            path: url,
          });
        }
      });
    });
    return response;
  }
  else {
    return {
      status:false,
      err:'Please send Url'
    };
  }
}
<%_}_%>
<%_} else {_%>
/**
 * 
 * Function used to create directory.
 * 
 * @param  {} dirPath
 */
const makeDirectory = async (directoryPath) => {

  if (!fs.existsSync(directoryPath)) {
    fs.promises.mkdir(directoryPath, { recursive: true }, (err) => {
      if (err) {
        return false;
      };
      return true;
    });
  }
  return true;
};

/**
 * 
 * Function used to upload file
 * 
 * @param  {} files
 * @param  {} fields
 */
async function uploadFiles (file, fields, fileCount,allowedFileTypes, maxFileSize, defaultDirectory) {

  let tempPath = file.path;
  let unlink;
  let fileName = file.name;

  let extension = path.extname(file.name);
  extension = extension.split('.').pop();

  fileType = file.type;

  if (allowedFileTypes.length) {
    //Check allowed extension;
    if (!allowedFileTypes.includes(extension)) {
      return {
        status: false,
        message: 'Filetype not allowed.'
      };
    }
  }

  // Check File Size
  const fileSize = ((file.size / 1024) / 1024);
  if (maxFileSize < fileSize) {
    return {
      status: false,
      message: `Allow file size upto ${maxFileSize} MB.`
    };
  }

  //Create New path
  let newPath = defaultDirectory + '/' + new Date().getTime() + path.extname(file.name);

  //Create Requested Directory,if given in request parameter.
  if (fields && fields.folderName) {
    let newDir = defaultDirectory + '/' + fields.folderName;
    const createDir = await makeDirectory(newDir);
    if (createDir) {
      if (fields.fileName) {
        newPath = newDir + '/' + fields.fileName + '-' + fileCount + path.extname(file.name);
        fileName = fields.fileName;
      }
    }
  }
  else if (fields && fields.fileName) {
    newPath = defaultDirectory + '/' + fields.fileName + '-' + fileCount + path.extname(file.name);
    fileName = fields.fileName;
  }
  
  const response = await new Promise(async (resolve, reject) => {
    fs.readFile(tempPath, function (err, data) {
      fs.writeFile(newPath, data, async function (err) {
  
        //Remove file from temp
        unlink = await unlinkFile(tempPath);
  
        if (unlink.status == false) {
          reject(unlink);
        } else {
          resolve({
            status: true,
            message: 'File upload successfully.',
            data: '/' + newPath
          });
        }
      });
    });
  });

  return response;
}

/**
 * 
 * Function used to unlink file.
 * 
 * @param  {} path
 */
async function unlinkFile (path) {

  fs.unlink(path, function (err) {
    if (err) {
      return {
        status: false,
        message: err.message
      };
    }
  });

  return { status: true };
}
<%_}_%>
<%_}_%>

module.exports = make<%-DB_MODEL_FC%>Controller;

<%_
function printSequelizeSort(sortObj){
  const finalSortArray = []
  for (const [key, value] of Object.entries(sortObj)) {
    let finalSort = []
    finalSort.push(key)
    finalSort.push(value === 1 ? 'ASC' : 'DESC')
    finalSortArray.push(finalSort)
  }
  return finalSortArray;
}
_%>