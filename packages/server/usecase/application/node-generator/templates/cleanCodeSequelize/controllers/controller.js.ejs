const response = require('../../../utils/response');
const {Op} = require("sequelize");

<%_var customRouteServices=[]
if(SERVICES_TO_IMPORT && SERVICES_TO_IMPORT.length){
    for(let i=0;i < SERVICES_TO_IMPORT.length;i++){ 
        if(SERVICES_TO_IMPORT[i] != DB_MODEL){ 
            customRouteServices.push(`${SERVICES_TO_IMPORT[i]}Service`)
        }else{
            customRouteServices.push(`${SERVICES_TO_IMPORT[i]}Service1`)
        }
    }
}
_%>
<%_ var methods = [] _%>

<%_for(let i=0;i< SUPPORT_API.length;i++){ _%>
  <%_ if(SUPPORT_API[i].method=="create") {_%>
      <%_methods.push('add'+DB_MODEL_FC) _%> 
      const add<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async ({ data <%_ if(SUPPORT_API[i].isLogin){ _%> ,loggedInUser <%_}_%>}) => {
          try {
              const originalData = data;
              delete originalData.updatedBy
              <%_ if(SUPPORT_API[i].isLogin){ _%>
                originalData.addedBy=loggedInUser.id
              <%_ } _%>
              let result = await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data :originalData});
              <%_if(SUPPORT_API[i].fieldSelection){_%>
              result.data = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(result.data);
              <%_}_%>
              return result;
            } catch (error) {
               return response.internalServerError();
            }
          };
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="createBulk") {_%>
    <%_methods.push('bulkInsert'+DB_MODEL_FC) _%>
    const bulkInsert<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async({body<%_ if(SUPPORT_API[i].isLogin){ _%> ,loggedInUser <%_}_%>})=>{
      try{
        let data = body.data;
        let result = await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data});
        <%_if(SUPPORT_API[i].fieldSelection){_%>
          if(result.data.length){
            for(let i=0;i< result.data.length; i++){
              result.data[i] = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(result.data[i]);
            }
          }
        <%_}_%>
        return result;
      }catch(error){
        return response.internalServerError();
      }
    }
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="partialUpdate") {_%>
    <%_methods.push('partialUpdate'+DB_MODEL_FC) _%>
    const partialUpdate<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) =>  async (id,data<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) =>{
        try {
          if (data && id){          
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
              let query = {}
              if (loggedInUser){
                  query = {
                      "id": {
                          [Op.eq]: id,
                          [Op.ne]: loggedInUser.id
                      }
                  }
              } else{
                return response.badRequest();
              }
            <%_}else{_%>
              let query = {id:id}
            <%_}_%>
            let result = await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data,query});
            <%_if(SUPPORT_API[i].fieldSelection){_%>
              if(Object.keys(result.data).length){
                result.data = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(result.data);
              }
            <%_}_%>
            return result;
          }
          return response.badRequest();
        }
        catch (error){
          return response.internalServerError();
        }
      }
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="update") {_%>
    <%_methods.push('update'+DB_MODEL_FC) _%>
    const update<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async (data, id<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) =>{
        try {
          if (id){          
            delete data.addedBy
            delete data.updatedBy
            <%_ if(SUPPORT_API[i].isLogin){ _%>
                data.updatedBy=loggedInUser.id
            <%_ } _%>
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
            let query = {}
            if (loggedInUser){
                query = {
                    "id": {
                        [Op.eq]: id,
                        [Op.ne]: loggedInUser.id
                    }
                }
            } else{
              return response.badRequest();
            }
            <%_}else{_%>
            let query = {id:id}
            <%_}_%>
            <%_         
            let nestedCalls={}
            if(SUPPORT_API[i].IS_NESTED_CALL){
                nestedCalls = SUPPORT_API[i].NESTED_CALLS
                if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                    for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                        <%-element.existingVariable%> = <%=JSON.parse(element.filter)%>
                    <%_}}
                }                
            }
            _%>
            let result = await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data,query});
            <%_if(SUPPORT_API[i].fieldSelection){_%>
              if(Object.keys(result.data).length){
                result.data = (({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_SUPPORT_API[i].fields.forEach((item,index)=>{_%><%-item%><%_if(SUPPORT_API[i].fields.length-1 !== index){_%>,<%_}_%><%_})_%>}))(result.data);
              }
            <%_}_%>
            return result;
          }
          return response.badRequest();
        }
        catch (error){
          return response.internalServerError();
        }
      }
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="bulkUpdate") {_%>
    <%_methods.push('bulkUpdate'+DB_MODEL_FC) _%>
    const bulkUpdate<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) =>  async(data<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) =>{
      try{
        if(data.filter && data.data){
          delete data.data.addedBy
          delete data.data.updatedBy
          <%_ if(SUPPORT_API[i].isLogin){ _%>
              data.data.updatedBy=loggedInUser.id
          <%_ } _%>
          <%_         
          nestedCalls={}
          if(SUPPORT_API[i].IS_NESTED_CALL){
              nestedCalls = SUPPORT_API[i].NESTED_CALLS
              if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                  for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                  data.filter = <%=JSON.parse(element.filter)%>                                            
                  <%_}}
              }                
          }
          _%>
          return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data: data.data,query :data.filter});
        }else{
          return response.badRequest();
        }
      }catch(error){
        return response.internalServerError();
      }
    }
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="delete") {_%>
    <%_methods.push('delete'+DB_MODEL_FC) _%>
      const delete<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async (data,id<%_if(SUPPORT_API[i].isLogin){_%>,loggedInUser,<%_}_%>options={})=>{
        try {
          if(!id){
            return response.badRequest();
          }
          <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
          let query = {}
          if (loggedInUser){
              query = {
                  "id": {
                      [Op.eq]: id,
                      [Op.ne]: loggedInUser.id
                  }
              }
          } else{
              return response.badRequest();
          }
          <%_}else{_%>
          let query = {id:id}
          <%_}_%>
          <%_         
          nestedCalls={}
          if(SUPPORT_API[i].IS_NESTED_CALL){
              nestedCalls = SUPPORT_API[i].NESTED_CALLS
              if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                  for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                      <%-element.existingVariable%> = <%=JSON.parse(element.filter)%>    
                  <%_}}
              }                
          }
          _%>
          return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data,query});
        } catch (error) {
          return response.internalServerError();
        }
      }
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="deleteMany") {_%>
      <%_methods.push('deleteMany'+DB_MODEL_FC) _%>
      <%_ if(DELETE_DEPENDENT_MODEL){ _%>
  const deleteMany<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async(data<%_if(SUPPORT_API[i].isLogin){_%>, loggedInUser<%_}_%>) => {
      try{
          if(data && data.ids){
            let ids = data.ids
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
            let query = {}
            if (loggedInUser){
                query = {
                    id: {
                        [Op.in]: ids,
                        [Op.ne]: loggedInUser.id
                    }
                }
            } else{
              return response.badRequest();
            }
            <%_}else{_%>
              let query = {id:{[Op.in]: ids}}
            <%_}_%>
            return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({ data, query});
          }
          return response.badRequest();
      }
      catch(error){
        return response.internalServerError();
      }
    }
  <%_ } else { _%>
  const deleteMany<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async(data<%_if(typeof USER_MODEL !== 'undefined' && USER_MODEL){_%>, loggedInUser<%_}_%>) => {
      try{
        let ids = data.ids;
        if (ids && (Array.isArray(ids) && ids.length > 0)) {
              <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
              let query = {}
              if (loggedInUser){
                  query = {
                      id: {
                          [Op.in]: ids,
                          [Op.ne]: loggedInUser.id
                      }
                  }
              } else{
                return response.badRequest();
              }
              <%_}else{_%>
              let query = {id:{[Op.in]: ids}}
              <%_}_%>
              const dataToUpdate = {
                isDeleted: true,
                <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
                updatedBy: loggedInUser.id,
                <%_}_%>
              }
              return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({dataToUpdate,query});
          }else{
            return response.badRequest();
          }
      }
      catch(error){
        return response.internalServerError();
      }
  }
  <%_ } _%>
  <%_ } _%>

  <%_ if(SUPPORT_API[i].method=="softDelete") {_%>
    <%_methods.push('softDelete'+DB_MODEL_FC) _%>
    const softDelete<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) =>  async({data,id<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>},options={})=>{
      try{
          if(id){
            let updated<%-DB_MODEL_FC%>
            <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
            let query = {}
            if (loggedInUser){
                query = {
                    id: {
                        [Op.eq]: id,
                        [Op.ne]: loggedInUser.id
                    }
                }
            }else{
              return response.badRequest();
            }
            <%_}else{_%>
            let query={id:id}
            <%_}_%>
            <%_         
            nestedCalls={}          
            if(SUPPORT_API[i].IS_NESTED_CALL){
                nestedCalls = SUPPORT_API[i].NESTED_CALLS
                if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                    for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                        <%-element.existingVariable%> = <%=JSON.parse(element.filter)%> 
                    <%_}}
                }                
            }
            _%>
            const dataToUpdate = {
              isDeleted: true,
              <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
              updatedBy: loggedInUser.id,
              <%_}_%>
            }
            return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data,dataToUpdate,query});
          }
          return response.badRequest();
      }catch(error){
        return response.internalServerError();
      }
    }
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="softDeleteMany") {_%>
      <%_methods.push('softDeleteMany'+DB_MODEL_FC) _%>
      <%_ if(DELETE_DEPENDENT_MODEL){ _%>
  const softDeleteMany<%-DB_MODEL_FC%> =  (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async (data,ids<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) => {
      try{
         if (ids && (Array.isArray(ids) && ids.length > 0)) {
              <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
              let query = {}
              if (loggedInUser){
                  query = {
                      id: {
                          [Op.in]: ids,
                          [Op.ne]: loggedInUser.id
                      }
                  }
              } else{
                return response.badRequest();
              }
              <%_}else{_%>
              let query = {id:{[Op.in]: ids,}}
              <%_}_%>
             return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data,query });
          }
          return response.badRequest();
      }catch(error){
        return response.internalServerError();
      }
  }
  <%_ } else { _%>
  const softDeleteMany<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async (ids<%_if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>) => {
      try{
           if (ids && (Array.isArray(ids) && ids.length > 0)) {
              <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
              let query = {}
              if (loggedInUser){
                  query = {
                      id: {
                          [Op.in]: ids,
                          [Op.ne]: loggedInUser.id
                      }
                  }
              } else{
                return response.badRequest();
              }
              <%_}else{_%>
              let query = {id:{[Op.in]: ids,}}
              <%_}_%>
              const options={}
             return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({query});
          }
          return response.badRequest();
      }catch(error){
        return response.internalServerError();
      }
  }
  <%_ } _%>
  <%_ } _%>

  <%_ if(SUPPORT_API[i].method=="findAll") {_%>
    <%_methods.push('findAll'+DB_MODEL_FC) _%>
      const findAll<%-DB_MODEL_FC%> = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async ({ data<%_ if(SUPPORT_API[i].isLogin){ _%>,loggedInUser<%_}_%>}) => {
        try {
          let query = {};
          let options = {};
          if (data.query !== undefined){
            query = { ...data.query };
          }
          if(data.options !== undefined){
            options = { ...data.options };
          }
          <%_ if(typeof USER_MODEL !== "undefined" && USER_MODEL && SUPPORT_API[i].isAuth){ _%>
          if (loggedInUser){
              query = {
                ...query,
              id: { [Op.ne]: loggedInUser.id }
              }
              if (data.query && data.query.id) {
                  Object.assign(query.id, { [Op.in]: [data.query.id] })
              }
          } else{
              return response.badRequest();
          }
          <%_}_%>
          <%_if(SUPPORT_API[i].fieldSelection){_%>
            if(options && options.select && options.select.length){
                options.attributes = <%=SUPPORT_API[i].fields%>.filter(Set.prototype.has, new Set(options.select));
            }else{
                options.attributes=<%=SUPPORT_API[i].fields%>
            }
          <%_} else {_%>
          if(options && options.select && options.select.length){
            options.attributes = options.select;
          }
          <%_}_%>
          <%_         
          nestedCalls={}
          if(SUPPORT_API[i].IS_NESTED_CALL){
              nestedCalls = SUPPORT_API[i].NESTED_CALLS
              if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                  for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                      <%-element.existingVariable%> = <%=JSON.parse(element.filter)%> 
                  <%_}}
              }                
          }
          _%> 
          return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data,query,options});
        }
        catch (error){
          return response.internalServerError();
        }
      };
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="findById") {_%>
    <%_methods.push('get'+DB_MODEL_FC+'ById') _%>
   const get<%-DB_MODEL_FC%>ById = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async(query, data = {}) =>{
      try {
       let options = {};
            if (data && data.populate && data.populate.length) options.populate = data.populate;
            if (data && data.select && data.select.length) options.select = data.select;
            <%_if(SUPPORT_API[i].fieldSelection){_%>
                let fieldSelect = <%=SUPPORT_API[i].fields%>
                options.select = {
                    ...options.select,
                    ...fieldSelect
                }
            <%_}_%>
        return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({data, query, options});  
      }
      catch (error){
        return response.internalServerError();
      }
    };
  <%_}_%>
  <%_ if(SUPPORT_API[i].method=="count") {_%>
    <%_methods.push('get'+DB_MODEL_FC+'Count') _%>
    const get<%-DB_MODEL_FC%>Count = (<%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase) => async(data) => {
        try {
            let where = data && data.where ? data.where : {};
            <%_         
                nestedCalls={}
                if(SUPPORT_API[i].IS_NESTED_CALL){
                    nestedCalls = SUPPORT_API[i].NESTED_CALLS
                    if(nestedCalls && nestedCalls.pre && nestedCalls.pre.length>0){ 
                        for(const element of nestedCalls.pre){ if(element.existingVariable && element.filter!==undefined){_%>
                            where=...<%=JSON.parse(element.filter)%>                      
                        <%_}}
                    }                
                }
                _%>
            return await <%-SUPPORT_API[i].method + DB_MODEL_FC %>Usecase({where});  
        } catch(error){
            return response.internalServerError();
        }
    }
<%_ } _%>
<%_}_%>

<%_if(typeof USER_MODEL !== "undefined" && USER_MODEL){_%>
  <%_methods.push('changePassword'); methods.push('updateProfile');  _%>
   
   const changePassword = (changePasswordUsecase) => async (params) => {
        try{
            return await changePasswordUsecase(params);
        }catch(error){
            return response.internalServerError();
        }
    }   
    const updateProfile = (updateProfileUsecase) => async (data,id) => {
        try{
            return await updateProfileUsecase({data,id});
        }catch(error){
            return response.internalServerError();
        }   
    }
  
<%_}_%>
<%_if(CUSTOM_ROUTES){_%>
  <%_CUSTOM_ROUTES.forEach((v,i)=>{ 
      methods.push(v.functionName)
      _%>
      <%_if(typeof(v.descriptions)!=='undefined'){_%>
      /* 
      * <%-v.descriptions%>
      */
      <%_}_%>
      const <%-v.functionName%> =async(data) =>{
          try{
              const <%-v.service%> = data
              
          <%_if(typeof(v.queryBuilder) !== "undefined" && v.queryBuilder.length > 0){_%>
              const combinedOutput = {}
              let result = <%_if(v.service==DB_MODEL){_%><%-v.service%>Service1<%_}else{_%><%-v.service%>Service<%_}_%>.<%-v.functionName%>();
              <%_ 
              const elements = v.queryBuilder
              for(let element of elements){ 
                  let elementModel_FC=""
                  if(element.queryMode !== 'codeBlock' && element.model){ 
                      elementModel_FC=element.model.charAt(0).toUpperCase() + element.model.slice(1);
                  }
              if(["findOneAndDelete","deleteMany"].includes(element.queryMode)){ _%>
              let <%-element.outputVariable%>=await <%-element.model%>CqService.<%-element.queryMode%>(<%-JSON.stringify(JSON.parse(element.filter))%>,<%-JSON.stringify(element.option)%>);
              <%_if(typeof element.outputSelect !== "undefined" && element.outputSelect.length){ element.outputSelect.push("id") _%>
              <%-element.outputVariable%> = (({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}))(<%-element.outputVariable%>);
              <%_}_%>
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_ } else if(["findOneAndUpdate","updateMany"].includes(element.queryMode)){ _%> 
              let <%-element.outputVariable%>=await <%-element.model%>CqService.<%-element.queryMode%>(<%-JSON.stringify(JSON.parse(element.filter))%>,
                  make<%-elementModel_FC%>(<%-JSON.stringify(element.data)%>,"update<%-elementModel_FC%>Validator"),
                  <%-JSON.stringify(element.option)%>);
              <%_if(typeof element.outputSelect !== "undefined" && element.outputSelect.length){ element.outputSelect.push("id") _%>
              <%-element.outputVariable%> = (({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}))(<%-element.outputVariable%>);
              <%_}_%>
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_ } else if(element.queryMode=="create"){ _%>                 
              let <%-element.outputVariable%>=await <%-element.model%>CqService.<%-element.queryMode%>(
                  make<%-elementModel_FC%>(<%-JSON.stringify(element.data)%>,"insert<%-elementModel_FC%>Validator"),
                  <%-JSON.stringify(element.option)%>);
              <%_if(typeof element.outputSelect !== "undefined" && element.outputSelect.length){ element.outputSelect.push("id") _%>
              <%-element.outputVariable%> = (({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}) => ({<%_element.outputSelect.forEach((item,index)=>{_%><%-item%><%_if(element.outputSelect.length-1 !== index){_%>,<%_}_%><%_})_%>}))(<%-element.outputVariable%>);
              <%_}_%>
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_ } else if(element.queryMode === "codeBlock"){_%>
                  <%-element.code%>
              <%_} else if(element.queryMode === "find" && element.model){_%>
              const <%-element.queryVarName%> = {}
              <%_if(element.filter){ _%>
              <%-element.queryVarName%>.filter =<%-element.filter%>
              <%_}_%>
              <%_if(element.skip){ _%>
              <%-element.queryVarName%>.skip = <%-JSON.stringify(element.skip)%>
              <%_}_%>
              <%_if(element.limit){ _%>
              <%-element.queryVarName%>.limit = <%-JSON.stringify(element.limit)%>
              <%_}_%>
              <%_if(element.populate && element.populate.length>0){ _%>
              <%-element.queryVarName%>.populate = <%-JSON.stringify(element.populate)%>
              <%_}_%>
              <%_if(element.sort){ _%>
              <%-element.queryVarName%>.order = <%=printSequelizeSort(JSON.parse(element.sort))%>
              <%_}_%>
              <%_if(element.select){ _%>
              <%-element.queryVarName%>.attributes = <%-JSON.stringify(element.select)%>
              <%_}_%>
              
              const <%-element.outputVariable%> = await <%-element.model%>CqService.<%-element.queryMode%>(<%-element.queryVarName%>)
              combinedOutput.<%-element.outputVariable%> = <%-element.outputVariable%>
              <%_}else if(element.queryMode === 'aggregate'){ _%>
              combinedOutput.<%-element.outputVariable%> = await <%-element.model%>CqService.<%-element.queryMode%>(<%-JSON.stringify(element.pipes)%>)
              <%_ } else if(element.queryMode === 'fileUpload'){ _%>
              <%_if(S3_UPLOAD){_%>

              let allowedFileTypes = <%=element.validationType%>;<%_var max_size = element.maxSize ? element.maxSize : 5%>
              let maxFileSize = <%=max_size%>; //In Megabyte

              // Setting up formidable options.
              const form = new formidable.IncomingForm();
              form.multiples = true;
              form.maxFileSize = 300 * 1024 * 1024; //300 MB
              form.maxFieldsSize = 100 * 1024 * 1024; //50 MB

              const uploadFileRes = await new Promise(async (resolve, reject) => {
              form.parse(req, async function (err, fields, files) { 

                let filePaths = [];
                let fileCount = 1;

                let fileArr = [];
                if (!files['file[]'] || files['file[]'].size == 0) {
                resolve({
                    'err': 'Please Select any one File',
                    'status': false
                });
                }
                if (!Array.isArray(files['file[]'])) {
                fileArr.push(files['file[]']);
                files['file[]'] = fileArr;
                }

                for (let file of files['file[]']) {
                let response = await uploadFiles(file,fields,fileCount++,allowedFileTypes, maxFileSize);
                if (response.status == false) {
                    filePaths.push({
                    'name': file.name,
                    'err': response.message,
                    'status': false
                    });
                } else {
                    filePaths.push({
                    'path': response.data,
                    'status': true
                    });
                }
              }
                resolve(filePaths);

            });
            });
            <%_if(S3_UPLOAD_PRIVATE){_%>
            let finalResponse = [];
            if (Array.isArray(uploadFileRes) && uploadFileRes.length){
                uploadFileRes = await new Promise(async (resolve, reject) => {
                    for (let u of uploadFileRes){
                    if (u.status && u.path) {
                        u = await generatePreSignedURL(u.path);
                        finalResponse.push(u);
                    }
                    }
                    resolve(finalResponse);
                });
            }
            <%_}_%>
        <%_} else {_%>

            let defaultDirectory = 'public/assets'
            let allowedFileTypes = <%=element.validationType%>;<%_ var max_size = element.maxSize ? element.maxSize : 5 _%>
            let maxFileSize = <%=max_size%>; //In Megabyte

            // Create Directory if not exist.
            await makeDirectory(defaultDirectory);

            // Setting up formidable options.
            const form = new formidable.IncomingForm();
            form.multiples = true;
            form.maxFileSize = 300 * 1024 * 1024; //300 MB
            form.maxFieldsSize = 100 * 1024 * 1024; //50 MB

            //Upload File one by one
            const uploadFileRes = await new Promise(async (resolve, reject) => {

            form.parse(req, async function (err, fields, files) {

                let filePaths = [];
                let fileCount = 1;

                let fileArr = [];
                if (!files['file[]'] || files['file[]'].size == 0) {
                resolve({
                    'err': 'Please Select any one File',
                    'status': false
                });
                }
                if (!Array.isArray(files['file[]'])) {
                fileArr.push(files['file[]']);
                files['file[]'] = fileArr;
                }

                for (let file of files['file[]']) {

                let response = await uploadFiles(file, fields, fileCount++,allowedFileTypes, maxFileSize, defaultDirectory);

                if (response.status == false) {
                    filePaths.push({
                    'name': file.name,
                    'err': response.message,
                    'status': false
                    });
                } else {
                    let url = response.data;
                    if (!validUrl.isUri(response.data)) {
                    response.data = response.data.replace('/public', '');
                    url = `${response.data}`;
                    }
                    filePaths.push({
                    'path': url,
                    'status': true
                    });
                }
                }
                resolve(filePaths);
            });
        });
        <%_}_%>
              combinedOutput.uploadFileRes = uploadFileRes; 
              <%_}_%>
          <%_ } _%>
          <%_ } _%>
          <%_if(typeof(v.queryBuilder) !== "undefined" && v.queryBuilder.length > 0){_%>
              if(combinedOutput){
                return message.successResponse({data:combinedOutput});
              }
          <%_}else{_%>
              let result = <%_if(v.service==DB_MODEL){_%><%-v.service%>Service1<%_}else{_%><%-v.service%>Service<%_}_%>.<%-v.functionName%>();
              if(result){
                return message.successResponse({data:result});
              }
          <%_}_%>
              
          }catch(error){
            return response.internalServerError();
          }
      }
  <%_})_%>
<%_}_%>

const removeEmpty = (obj) => {
    Object.entries(obj).forEach(([key,value])=>{
        if(value === undefined){
            delete obj[key]
        }
    })
    return obj
};


module.exports = {
    <%_methods.forEach(v=> {_%>
    <%-v%>,
    <%_})_%>
    <%_if(typeof USER_MODEL !== "undefined" && USER_MODEL){_%>
    changePassword,
    updateProfile,
    <%_}_%>
}

